# All the memo is kept here. Changes made by me(AndCharalampous) are inserted here #
# ΠΡΟΣΟΧΗ: ΘΑ ΠΡΟΣΠΑΘΗΣΕΙΣ ΝΑ ΣΚΕΦΤΕΙΣ ΟΤΙ ΨΩΝΙΣΤΗΚΑ. ΠΡΟΣΠΑΘΩ ΝΑ ΕΚΠΑΙΔΕΥΤΩ ΓΙΑ ΠΡΟΤΖΕΚΤ <3 #

Υπόμνημα:
	@ --> Written by Andreas
	P --> Written by Panagiotis
	...........................

	* --> Αλλαγές που έγιναν.
	~ --> Προτιμήσεις που δεν εφαρμόστηκαν (Για συζήτηση).
	> --> Τι πρέπει να προσέξουμε στην συνέχεια.
	} --> Δουλεία που θα κάνω εγώ στην συνέχεια.
	" --> Πλάνο


@ Wed 25/07 - 03:12
....................
	* Φτιάξιμο δομής git
	* Έλεγχος κώδικα, εισαγωγή σχολίων(εκτός read_user_input()).
	* Προτίμησα σαν error code(returns) το -1 αντί το 1.
	* Άλλαξα την read_filter. Πλέον θεωρούνται σωστά τα εξής:
		+ Αρνητικοί, θετικοί και το μηδέν.
		+ Στους κινητής υποδιαστολής γίνεται αποκοπή δεκαδικών(π.χ 2.3 --> 2).
		+ Οτιδήποτε άλλο απορρίπτεται και η γραμμή ξαναδιαβάζεται.
	* Δημιουργία makefile. Όταν πρέπει, θα γίνει αλλαγή του CC σε mpicc.

	~ Η εισαγωγή των παραμέτρων(resolutions, seed etc.) να γίνεται από γραμμή εντολών, έχοντας και defaults.
	~ Στην allocate_mem_filter() να μην δίνεται το φίλτρο σαν όρισμα, αλλά να δημιουργείται και να επιστρέφεται.
	~ Μπορούμε να ενώσουμε την allocate_mem_filter() με την read_filter().
	~ Αποφυγή includes στα .h, εισαγωγή μόνο στα αντίστοιχα πηγαία(π.χ να φύγει το stdio από utils.h) -> agree

	> Το φίλτρο είναι μορφής int**, όμως μετά την κανονικοποίηση θα κρατάει float. -> agree
	> Memory allocations και memory errors(valgrind)


@ Wed 25/07 - 16:45
....................	ο πίνακας static για να μην κάνουμε malloc κλπ οπότε και το filter το έκανα χωρίς Malloc για να είναι ομοιόμορφο.

	* Εύρεση πράξεων για διαμερισμό(στο χαρτί).
	* Μεταφορά includes από το utils.h.
	* Φτιάξιμο Κανονικοποιημένου Φίλτρου:
		+ Εάν sum == 0 || sum == 1, μένουν τα ίδια.

	~ Σχόλια:
	-> Καλύτερα όλα // και μόνο ετικέτες /* */	   ή παντού /* */  <-----------------------------------------------------
		+ Στην ίδια γραμμή με εντολή: // Σχόλιο
		+ Επεξήγηση πάνω από εντολές: /* Σχόλιο */
		+ Ετικέτες αρχείων: /* Σχόλιο
		                     * Σχόλιο
				     */
		+ Επεξηγήσεις συναρτήσεων: /* Σχόλιο */
		                           /* Σχόλιο */
					   ...
					   /* Σχόλιο */

	> Memory allocations και memory errors(valgrind).
	> Να αποφασίσουμε το seed για τυχαίες εικόνες. <-------------- οκ
	> Arguments vs Broadcast(} Args).
	} Διαμερισμός(δεν χρειάζεται να ασχοληθείς καθόλου).


P Thu 26/07 - 10:13
....................
	* broadcast done -> είναι και πολύ καλό πιστεύω(στο Mpi μας χτυπάει το allocation μαλλόν κάνει Init όλους τους pointer να 		δείχνουν σε Null Και μετά καλούμε την allocation απλά βγαίνει αυτός ο έλεγχος. Δεν τον αλλαξά στο git μιας και έκανα αλλαγές στο 	δικό μου μόνο και ανέβασα μόνο Main .
	-> Να γίνει το **filter ->  filter[size][size]
	" Άρα μένει να κάνουμε allocate τους πίνακες(find ranges), fill pixels, find neigbrous. Μετά χτυπάμε ένα barrier και timer και 	αρχίζουν οι υπολογισμοί. Με τους γείτονες μπορώ να βρώ εγώ τα τυπάκια και για το random να βρω ένα seed(τι βαθμό τυχαίοτητας 		θέλεις από 1-5 :p). Πρέπει να συζητήσουμε κάποια στιγμή σήμερα αύριο για την σύγκλιση - πότε σταματάει το loop.


P Fri 27/07 - 17:07
....................
	* Έβγαλα το broadcast μιας και κάθε processe έχει δικό του range στον πίνακα και πρέπει να στέλουμε ένα ένα(και το broadcast
	στέλνει πολλά μυνήματα από πίσω)
	* Ο πίνακας έγινε static του filter για καλύτερη διαχείριση αν και δεν έχει διαφορά απλά προτήμησα το Struct arguments να είναι
	ο πίνακας static για να μην κάνουμε malloc κλπ οπότε και το filter το έκανα χωρίς Malloc για να είναι ομοιόμορφο.
	* Γενικά η λογική είναι σωστή, τα indexes στα loop Και στο send είναι σωστά κάτι γίνεται και δεν έχει σωστή ανάθεση όταν
	στέλνετε κατί μικρό θα είναι
	* Όποτε πάνω κάτω τα επόμενα βήματα είναι debug, find neighbours, fill arrays και μετά λίγο η λόγική πως θα ανταλάζονται τα 		μυνήματα πως θα στέλνονται από που κλπ κλπ και μετά μένουν υπολογισμοί και wait που είναι πολύ ποιο εύκολη δουλεία. Το όλο θέμα 	είναι στα ifs Κλπ για τον πίνακα με μυνήματα, hallow points οριακά σημεία κλπ.


@ Sun 05/08 - 17:43
...................
	* Το Makefile δουλεύει για MPI.
	* Από την κύρια διεργασία[0], γίνεται Input, υπολογίζεται το πλάτος και ύψος κατα διεργασία, όπως και τα υπόλοιπα τους.
	  Έπειτα τα μοιράζει στις άλλες διεργασίες.
	* Ο υπολογισμός όλων των παραμέτρων που αφορούν την κάθε διεργασία, γίνεται μέσα στην εκάστοτε διεργασία.
	* Αλλαγή στον τρόπο δήλωσης derived τύπου, ο οποίος τώρα λειτουργεί.
	* Εύρεση θέσης μέσα στην εικόνα(row-column id) και γειτόνων για κάθε διεργασία. -1 σε περίπτωση ακριανής τοποθεσίας.
	* Εύρεση pixels που θα αναλάβει η κάθε διεργασία. Δημιουργία seed και τυχαίας εικόνας.
		+ Seed = seed_given * ((my_rank + 333)^2)

	~ Στο διάβασμα των παραμέτρων, να περνάμε το Args_type για λιγότερες αναθέσεις και μνήμη. -> ναι
	~ Ίσως δεν χρειάζεται να έχουν όλες οι διεργασίες το width και height της όλης εικόνας. -> Εμ αστο μπορει στο τελος να τυπωνουμε το ποσοστο που έχει καθε διεργασία που σερβιρε πχ
	~ Σχετικά με τον κορεσμό(πότε σταματά το loop), μπορούμε καθώς υπολογίζουμε τις νέες τιμές, αφού έχουμε 2 πίνακες, να κάνουμε απευθείας
	  έλεγχο. Αν η νέα τιμή δεν ισούται με την παλιά τότε κάνουμε μια μεταβλητή=1. Στο τέλος του γύρου, η διεργασία 0 δουλεύει σαν διαιτητής
	  και ελέγχει αν υπάρχει έστω και μια που δεν έφτασε σε κορεσμό, και λέει στις διεργασίες να συνεχίζουν ή να σταματήσουν.-> Εμ οχι ειναι λαθος να παιζει μυνηματα με μαστερ νομιζω, κοιτα αν δεν κανω λαθος αλλα πρεπει
	  να το ελεξουμε αν μια διεργασία δεν αλλαζει θα σταματαει οποτε θα βαλουμε απλα εναν barrier εξω απο το loop και μολις φτασουν ολες τοτε μονο πχ μπορει να παρει ο αρχηγος στατιστικα,  δεν χρειάζεται καθε φορα να ελέγχει τι γίνεται μονο καθε διεργασία αν αλαξε ο πινακας της
	~ Να ψάξουμε το MPI_Null_process, γενικά αν υπάρχει, για να είναι πιο αυτόματο το πρόγραμμα. Αλλιώς έλεγχο για -1.

	> Έλεγχος αν ο αριθμός των διεργασιών είναι τέλειο τετράγωνο.
	> Έλεγχος αν το μήκος και πλάτος εικόνας είναι μεγαλύτερο ή ίσο από ρίζα αριθμού διεργασιών.
	> Memory allocations και memory errors(valgrind).

	} Θα ασχοληθώ κυρίως με την επικοινωνία μεταξύ των γειτόνων και θα προχωρήσω στο loop.

	" Γενικά προχωράμε μέχρι να βγει η άσκηση και μετά θα εφαρμόσουμε όποιαδήποτε βελτίωση.


@ Tue 07/08 - 01:31
...................
	* Φτιάξιμο του MPI_PROC_NULL. Στην τελική το ίδιο πράγμα είναι γιατί είναι defined σαν -1.
	* Προσθήκη ελέγχου για διεργασίες τέλειου τετραγώνου.
	* Στο input δίνεται το my_args, αποφεύγοντας περιττές αποδόσεις τιμών και μνήμη.
	* Προσθήκη ελέγχου ότι τα δοθέν ύψος και πλάτος πρέπει να είναι μεγαλύτερα η ίσα με sqrt(comm_size). Επίσης μέχρι 3500 pixels.
	* Προσθήκη κανόνα ότι οι τιμές του φίλτρου είναι μεταξύ -10 και 10.

	> Επαλήθευση αν το MPI_Abort() είναι σωστό, όταν δεν δόθηκε τέλειο τετράγωνο. Δηλαδή είναι σωστός τρόπος για τερματισμό;
	> Πρέπει να δούμε πώς θα υλοποιήσουμε την όλη φάση με τα γειτονικά:
	   + Πώς θα τα πασάρουμε έξυπνα στους γείτονες.
	   + Πώς θα τα δεχτούμε από γείτονες.
	   + Πού θα τοποθετούνται ακριβώς.
	   + κτλπ.
	> Memory allocations και memory errors(valgrind). Το έτρεξα από περιέργια και είδα ότι δεν υπήρχαν leaks, ενώ δεν κάνουμε free τα pixels.

	} Λογικά αύριο δεν θα ασχοληθώ με κώδικα, αλλά θα προσπαθήσω να δω στο χαρτί τα περί μοιράσματος κτλπ.

	" Αλγόριθμος μοιράσματος, Υπολογισμός τιμών, Επανάληψη, Επικοινωνία, Σύγκλιση, Timings, Συγκρίσεις.


@ Tue 13/09 - 18:03
...................
	* Σετάρισμα των άκρων σε -1 για ευκολία διαβάσματος στον έλεγχο, θα αλλάξει στην συνέχεια.
	* Φτιάξιμο τύπου στήλης(column_type). Υπήρχε θέμα στον ορισμό.
	* Φτιάξιμο sends-recvs. Συγκεκριμένα αντιστράφηκαν τα tags(πχ όταν κάνεις send στον Ν, κάνεις το tag = S, για να το βρει απευθείας ο receiver-εύκολοι ελέγχοι μετά).
	* Αποθήκευση δεδομένων σε δύο αρχεία για κάθε διεργασία για έλεγχο. FilexxxA(αρχική) και FilexxxB(μετά το recv), όπου xxx το rank της διεργασίας.
	* Φτιάξιμο του loop των recv. Από active_neighbrous -> 8, καθώς πρέπει να προσπεράσουμε τα MPI_PROC_NULL.
	* Γενικός Σχολιασμός.

	> Έγινε έλεγχος για διαστάσεις 9x5. Στα 9x16 υπήρχε error.
	> Σε περισσότερα από 1 iterations υπάρχει error.
	> Πρέπει να δούμε σχετικά με το τι θα γίνει με τις default ακριανές τιμές, όταν δεν υπάρχει γείτονας.
	> Πρέπει να βρούμε την έξυπνη γενική απόφαση όταν δεχόμαστε δεδομένα. Αν είμαστε έτοιμοι δηλαδή να υπολογίσουμε κάποια άκρη.
	> Memory allocations και memory errors(valgrind). Το έτρεξα από περιέργια και είδα ότι δεν υπήρχαν leaks, ενώ δεν κάνουμε free τα pixels.

	} Ίσως συνεχίσω σήμερα για τo inner convolution και τα errors.

	" Υπολογισμός τιμών, Επανάληψη, Σύγκλιση, Timings, Συγκρίσεις.


@ Tue 13/09 - 22:00
...................
	* Φτιάξιμο συνεχόμενου 2D πίνακα για την εικόνα μετά.
	* Δημιουργία ενός μικρού script, στο οποίο δίνεις το file με τα περιεχόμενα του πίνακα μιας διεργασίας και το εκτυπώνεις, χρωματίζοντας τα όρια. Για ευκολία επαλήθευσης.
	* Φτιάξιμο του error για παράδειγμα 9x16 διαστάσεις.
	* Φτιάξιμο του error των πολλών iterations. Δεν ελέχθηκαν οι τιμές όμως.

	> Υποτίθεται ο τύπος του υπολογισμού είναι κελί εικόνας * κελί φίλτρου. Όμως, αρχικά το φίλτρο έχει floating τιμες και δεύτερον πολύ μικρές (< 0.5).
	  Έγραψα την πράξη όπως όπως και βλέπουμε.
	> Το σκέφτηκα θεωρητικά και ίσως έχουμε θέμα με τους πίνακες. Νομίζω ότι δεν αρκεί η ανταλλαγή των δεικτών που
	  κάνουμε, διότι μόνο η [0] θέση θα δείχνει σωστά. Οι υπόλοιπες [1] [2] ... θα δείχνουν εκεί που έδειχναν πριν.
	> Memory allocations και memory errors(valgrind). Το έτρεξα από περιέργια και είδα ότι δεν υπήρχαν leaks, ενώ δεν κάνουμε free τα pixels.

	} Θα συνεχίσω μάλλον μετά τις 17/09.

	" Υπολογισμός τιμών, Επανάληψη, Σύγκλιση, Timings, Συγκρίσεις, RGB εικόνες, Ακριανές τιμές όταν NULL.


@ Tue 20/09 - 23:16
...................
	* Έλεγχος λογικής. Πολύ καλή δουλειά. Όλα εντάξει, μόνο δεν έλεγξα όλες τις πράξεις για το convolution.
		+ Υπήρχε λάθος στις πράξεις στην γραμμή 659. Κάπου αντί height είχες width και χτυπούσε seg_fault. Διορθώθηκε και δεν χτυπάει seg_fault.
		+ Λάθος στην 803 και 805, διορθώθηκε.
		+ Ίσως υπάρχουν και άλλα παρόμοια. Δεν πρόλαβα να ελέγξω τα υπόλοιπα. Έκανα έλεγχο με 1900x800, 1 seed iterations και φίλτρο με άσσους.
	* Ανακάλυψα ότι το leak που έχουμε είναι γενικά με το Finalize(). Αν έβαζες και --show-leak-kinds=all έβγαζε και leaks από το Init. Απλά τα αγνοούμε γιατί είναι φυσικά. Δες τα links.
		+ https://stackoverflow.com/questions/8471773/mpi-memory-leak
		+ https://www.open-mpi.org/faq/?category=debugging#valgrind_clean
		+ Γενικά δεν βρήκα άλλα leaks.
	* Ελάχιστο σχολίασμα κώδικα.

	> Ίσως να λάβουμε υπόψη μας την περίπτωση που δοθεί 1 διεργασία, γιατί είναι τέλειο τετράγωνο. Άπλα ένα if πριν τα άλλα 8.
	> Μπορούμε να απλοποιήσουμε τους ελέγχους για το σε ποιά κατηγορία ειναι η κάθε διεργασία, μπορούμε π.χ για τις κάτω(γραμμή 1095) να βάλουμε το row_id == procs_per_line_1,
	  αφού η κάτω αριστερά και δεξιά έχουν ήδη μπει στα ifs τους.
	> Να βρούμε ό,τι απορία έχουμε και θα ρωτήσω τον Κοτρώνη την Τρίτη.

	} Αυτές τις μέρες είναι λίγο δύσκολο να συμβαδίσω, για αυτό το καλύτερο που μπορούμε να κάνουμε είναι να μου λές ό,τι χρειάζεσαι να κάνω και μολις βρίσκω χρόνο θα το βλέπω.

P  21/09 - 13:11
....................
-> Outer independent done
-> no leaks
-> -> to do -> δημηουργία μεταβλητών και καλύτερα ονόματα my_width_inc_1, my_width_dec_1 κλπ
----> Αν είναι δες outer απλά τρέξε το και σύκγρινε Α - Β (9 proc)

P  22/09
----------
outers done
check again e, h, g, h , i
change frequent vars + messages

@ Wed 27/09 - 23:00
...................
	* Ελάχιστος έλεγχος για ποικίλες εκτελέσεις.
	* Μετρήσεις στο MPI.
	* Χρήση OpenMp:
		+ Χρησιμοποιείται OpenMp για τα διπλά for που υπολογίζουν τα εσωτερικά pixels.
		+ Στις πρώτες γραμμές του κώδικα μπορούμε να ορίσουμε το ntrs με τον αριθμό των threads που θέλουμε.
		+ Προσαρμογή makefile.
		+ Μετρήσεις στο OpenMp.
	* Ανακάλυψα ότι τα linux της σχολής δεν μπορούν να μας προσφέρουν σχεδόν τίποτα όσον αφορά το OpenMp.

	~ Γενικά μπορούμε να εφαρμόσουμε OpenMp και στα ακριανά, αν και θα έχουν απειροελάχιστο κέρδος.

	} Δεν χρειάζεται να ασχοληθείς με OpenMp, θα σου εξηγήσω αύριο τα ελάχιστα που χρειάζονται, για να τα συζητήσουμε.


@ Fri 28/09 - 23:49
...................
	* Έναρξη προσθήκης επιλογής RGB:
		+ Προσθήκη μεταβλητής μπαλαντέρ(mult). Θα έχει την κατάλληλη τιμή για να έχουμε μόνο μια φορα τις πράξεις.
		+ Εισαγωγή μπαλαντέρ στις πράξεις εύρεσης μεγέθους και recv/sends.

		~ Μετά την εισαγωγή της μπαλαντέρ, θα ήταν καλό να δηλώναμε κάποια επιπλέον frequent variables
		~ Πρέπει να δουλέψουμε λίγο με τα hallow points όταν δεν υπάρχει γείτονας.

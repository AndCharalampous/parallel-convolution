# All the memo is kept here. Changes made by me(AndCharalampous) are inserted here #
# ΠΡΟΣΟΧΗ: ΘΑ ΠΡΟΣΠΑΘΗΣΕΙΣ ΝΑ ΣΚΕΦΤΕΙΣ ΟΤΙ ΨΩΝΙΣΤΗΚΑ. ΠΡΟΣΠΑΘΩ ΝΑ ΕΚΠΑΙΔΕΥΤΩ ΓΙΑ ΠΡΟΤΖΕΚΤ <3 #

Υπόμνημα:
	@ --> Written by Andreas
	P --> Written by Panagiotis
	...........................

	* --> Αλλαγές που έγιναν.
	~ --> Προτιμήσεις που δεν εφαρμόστηκαν (Για συζήτηση).
	> --> Τι πρέπει να προσέξουμε στην συνέχεια.
	} --> Δουλεία που θα κάνω εγώ στην συνέχεια.
	" --> Πλάνο


@ Wed 25/07 - 03:12
....................
	* Φτιάξιμο δομής git
	* Έλεγχος κώδικα, εισαγωγή σχολίων(εκτός read_user_input()).
	* Προτίμησα σαν error code(returns) το -1 αντί το 1.
	* Άλλαξα την read_filter. Πλέον θεωρούνται σωστά τα εξής:
		+ Αρνητικοί, θετικοί και το μηδέν.
		+ Στους κινητής υποδιαστολής γίνεται αποκοπή δεκαδικών(π.χ 2.3 --> 2).
		+ Οτιδήποτε άλλο απορρίπτεται και η γραμμή ξαναδιαβάζεται.
	* Δημιουργία makefile. Όταν πρέπει, θα γίνει αλλαγή του CC σε mpicc.

	~ Η εισαγωγή των παραμέτρων(resolutions, seed etc.) να γίνεται από γραμμή εντολών, έχοντας και defaults.
	~ Στην allocate_mem_filter() να μην δίνεται το φίλτρο σαν όρισμα, αλλά να δημιουργείται και να επιστρέφεται.
	~ Μπορούμε να ενώσουμε την allocate_mem_filter() με την read_filter().
	~ Αποφυγή includes στα .h, εισαγωγή μόνο στα αντίστοιχα πηγαία(π.χ να φύγει το stdio από utils.h) -> agree

	> Το φίλτρο είναι μορφής int**, όμως μετά την κανονικοποίηση θα κρατάει float. -> agree
	> Memory allocations και memory errors(valgrind)


@ Wed 25/07 - 16:45
....................	ο πίνακας static για να μην κάνουμε malloc κλπ οπότε και το filter το έκανα χωρίς Malloc για να είναι ομοιόμορφο.

	* Εύρεση πράξεων για διαμερισμό(στο χαρτί).
	* Μεταφορά includes από το utils.h.
	* Φτιάξιμο Κανονικοποιημένου Φίλτρου:
		+ Εάν sum == 0 || sum == 1, μένουν τα ίδια.

	~ Σχόλια:
	-> Καλύτερα όλα // και μόνο ετικέτες /* */	   ή παντού /* */  <-----------------------------------------------------
		+ Στην ίδια γραμμή με εντολή: // Σχόλιο
		+ Επεξήγηση πάνω από εντολές: /* Σχόλιο */
		+ Ετικέτες αρχείων: /* Σχόλιο
		                     * Σχόλιο
				     */
		+ Επεξηγήσεις συναρτήσεων: /* Σχόλιο */
		                           /* Σχόλιο */
					   ...
					   /* Σχόλιο */

	> Memory allocations και memory errors(valgrind).
	> Να αποφασίσουμε το seed για τυχαίες εικόνες. <-------------- οκ
	> Arguments vs Broadcast(} Args).
	} Διαμερισμός(δεν χρειάζεται να ασχοληθείς καθόλου).


P Thu 26/07 - 10:13
....................
	* broadcast done -> είναι και πολύ καλό πιστεύω(στο Mpi μας χτυπάει το allocation μαλλόν κάνει Init όλους τους pointer να 		δείχνουν σε Null Και μετά καλούμε την allocation απλά βγαίνει αυτός ο έλεγχος. Δεν τον αλλαξά στο git μιας και έκανα αλλαγές στο 	δικό μου μόνο και ανέβασα μόνο Main .
	-> Να γίνει το **filter ->  filter[size][size]
	" Άρα μένει να κάνουμε allocate τους πίνακες(find ranges), fill pixels, find neigbrous. Μετά χτυπάμε ένα barrier και timer και 	αρχίζουν οι υπολογισμοί. Με τους γείτονες μπορώ να βρώ εγώ τα τυπάκια και για το random να βρω ένα seed(τι βαθμό τυχαίοτητας 		θέλεις από 1-5 :p). Πρέπει να συζητήσουμε κάποια στιγμή σήμερα αύριο για την σύγκλιση - πότε σταματάει το loop.


P Fri 27/07 - 17:07
....................
	* Έβγαλα το broadcast μιας και κάθε processe έχει δικό του range στον πίνακα και πρέπει να στέλουμε ένα ένα(και το broadcast
	στέλνει πολλά μυνήματα από πίσω)
	* Ο πίνακας έγινε static του filter για καλύτερη διαχείριση αν και δεν έχει διαφορά απλά προτήμησα το Struct arguments να είναι
	ο πίνακας static για να μην κάνουμε malloc κλπ οπότε και το filter το έκανα χωρίς Malloc για να είναι ομοιόμορφο.
	* Γενικά η λογική είναι σωστή, τα indexes στα loop Και στο send είναι σωστά κάτι γίνεται και δεν έχει σωστή ανάθεση όταν
	στέλνετε κατί μικρό θα είναι
	* Όποτε πάνω κάτω τα επόμενα βήματα είναι debug, find neighbours, fill arrays και μετά λίγο η λόγική πως θα ανταλάζονται τα 		μυνήματα πως θα στέλνονται από που κλπ κλπ και μετά μένουν υπολογισμοί και wait που είναι πολύ ποιο εύκολη δουλεία. Το όλο θέμα 	είναι στα ifs Κλπ για τον πίνακα με μυνήματα, hallow points οριακά σημεία κλπ.


@ Sun 05/08 - 17:43
...................
	* Το Makefile δουλεύει για MPI.
	* Από την κύρια διεργασία[0], γίνεται Input, υπολογίζεται το πλάτος και ύψος κατα διεργασία, όπως και τα υπόλοιπα τους.
	  Έπειτα τα μοιράζει στις άλλες διεργασίες.
	* Ο υπολογισμός όλων των παραμέτρων που αφορούν την κάθε διεργασία, γίνεται μέσα στην εκάστοτε διεργασία.
	* Αλλαγή στον τρόπο δήλωσης derived τύπου, ο οποίος τώρα λειτουργεί.
	* Εύρεση θέσης μέσα στην εικόνα(row-column id) και γειτόνων για κάθε διεργασία. -1 σε περίπτωση ακριανής τοποθεσίας.
	* Εύρεση pixels που θα αναλάβει η κάθε διεργασία. Δημιουργία seed και τυχαίας εικόνας.
		+ Seed = seed_given * ((my_rank + 333)^2)

	~ Στο διάβασμα των παραμέτρων, να περνάμε το Args_type για λιγότερες αναθέσεις και μνήμη. -> ναι
	~ Ίσως δεν χρειάζεται να έχουν όλες οι διεργασίες το width και height της όλης εικόνας. -> Εμ αστο μπορει στο τελος να τυπωνουμε το ποσοστο που έχει καθε διεργασία που σερβιρε πχ
	~ Σχετικά με τον κορεσμό(πότε σταματά το loop), μπορούμε καθώς υπολογίζουμε τις νέες τιμές, αφού έχουμε 2 πίνακες, να κάνουμε απευθείας
	  έλεγχο. Αν η νέα τιμή δεν ισούται με την παλιά τότε κάνουμε μια μεταβλητή=1. Στο τέλος του γύρου, η διεργασία 0 δουλεύει σαν διαιτητής
	  και ελέγχει αν υπάρχει έστω και μια που δεν έφτασε σε κορεσμό, και λέει στις διεργασίες να συνεχίζουν ή να σταματήσουν.-> Εμ οχι ειναι λαθος να παιζει μυνηματα με μαστερ νομιζω, κοιτα αν δεν κανω λαθος αλλα πρεπει
	  να το ελεξουμε αν μια διεργασία δεν αλλαζει θα σταματαει οποτε θα βαλουμε απλα εναν barrier εξω απο το loop και μολις φτασουν ολες τοτε μονο πχ μπορει να παρει ο αρχηγος στατιστικα,  δεν χρειάζεται καθε φορα να ελέγχει τι γίνεται μονο καθε διεργασία αν αλαξε ο πινακας της
	~ Να ψάξουμε το MPI_Null_process, γενικά αν υπάρχει, για να είναι πιο αυτόματο το πρόγραμμα. Αλλιώς έλεγχο για -1.

	> Έλεγχος αν ο αριθμός των διεργασιών είναι τέλειο τετράγωνο.
	> Έλεγχος αν το μήκος και πλάτος εικόνας είναι μεγαλύτερο ή ίσο από ρίζα αριθμού διεργασιών.
	> Memory allocations και memory errors(valgrind).

	} Θα ασχοληθώ κυρίως με την επικοινωνία μεταξύ των γειτόνων και θα προχωρήσω στο loop.

	" Γενικά προχωράμε μέχρι να βγει η άσκηση και μετά θα εφαρμόσουμε όποιαδήποτε βελτίωση.


@ Tue 07/08 - 01:31
...................
	* Φτιάξιμο του MPI_PROC_NULL. Στην τελική το ίδιο πράγμα είναι γιατί είναι defined σαν -1.
	* Προσθήκη ελέγχου για διεργασίες τέλειου τετραγώνου.
	* Στο input δίνεται το my_args, αποφεύγοντας περιττές αποδόσεις τιμών και μνήμη.
	* Προσθήκη ελέγχου ότι τα δοθέν ύψος και πλάτος πρέπει να είναι μεγαλύτερα η ίσα με sqrt(comm_size). Επίσης μέχρι 3500 pixels.
	* Προσθήκη κανόνα ότι οι τιμές του φίλτρου είναι μεταξύ -10 και 10.

	> Επαλήθευση αν το MPI_Abort() είναι σωστό, όταν δεν δόθηκε τέλειο τετράγωνο. Δηλαδή είναι σωστός τρόπος για τερματισμό;
	> Πρέπει να δούμε πώς θα υλοποιήσουμε την όλη φάση με τα γειτονικά:
	   + Πώς θα τα πασάρουμε έξυπνα στους γείτονες.
	   + Πώς θα τα δεχτούμε από γείτονες.
	   + Πού θα τοποθετούνται ακριβώς.
	   + κτλπ.
	> Memory allocations και memory errors(valgrind). Το έτρεξα από περιέργια και είδα ότι δεν υπήρχαν leaks, ενώ δεν κάνουμε free τα pixels.

	} Λογικά αύριο δεν θα ασχοληθώ με κώδικα, αλλά θα προσπαθήσω να δω στο χαρτί τα περί μοιράσματος κτλπ.

	" Αλγόριθμος μοιράσματος, Υπολογισμός τιμών, Επανάληψη, Επικοινωνία, Σύγκλιση, Timings, Συγκρίσεις.


@ Tue 13/08 - 18:03
...................
	* Σετάρισμα των άκρων σε -1 για ευκολία διαβάσματος στον έλεγχο, θα αλλάξει στην συνέχεια.
	* Φτιάξιμο τύπου στήλης(column_type). Υπήρχε θέμα στον ορισμό.
	* Φτιάξιμο sends-recvs. Συγκεκριμένα αντιστράφηκαν τα tags(πχ όταν κάνεις send στον Ν, κάνεις το tag = S, για να το βρει απευθείας ο receiver-εύκολοι ελέγχοι μετά).
	* Αποθήκευση δεδομένων σε δύο αρχεία για κάθε διεργασία για έλεγχο. FilexxxA(αρχική) και FilexxxB(μετά το recv), όπου xxx το rank της διεργασίας.
	* Φτιάξιμο του loop των recv. Από active_neighbrous -> 8, καθώς πρέπει να προσπεράσουμε τα MPI_PROC_NULL.
	* Γενικός Σχολιασμός.

	> Έγινε έλεγχος για διαστάσεις 9x5. Στα 9x16 υπήρχε error.
	> Σε περισσότερα από 1 iterations υπάρχει error.
	> Πρέπει να δούμε σχετικά με το τι θα γίνει με τις default ακριανές τιμές, όταν δεν υπάρχει γείτονας.
	> Πρέπει να βρούμε την έξυπνη γενική απόφαση όταν δεχόμαστε δεδομένα. Αν είμαστε έτοιμοι δηλαδή να υπολογίσουμε κάποια άκρη.
	> Memory allocations και memory errors(valgrind). Το έτρεξα από περιέργια και είδα ότι δεν υπήρχαν leaks, ενώ δεν κάνουμε free τα pixels.

	} Ίσως συνεχίσω σήμερα για τo inner convolution και τα errors.

	" Υπολογισμός τιμών, Επανάληψη, Σύγκλιση, Timings, Συγκρίσεις.
